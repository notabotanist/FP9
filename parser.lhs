


Enscript Output






This is a parser for the mini-language, based on the Parsing module from the
class notes. It will either fail or consume all input. To be useful it has to
be modified to create a representation of the constructs which it recognizes.

> module Main where
> import Prelude hiding (div, id, mod)
> import Monad (mplus)
> import Parsing
> import System (getArgs)

:run test path
convenience function to parse the contents of a file.

> test = do
>   args <- getArgs
>   contents <- readFile (head args)
>   putStrLn (show (parse prog contents))

the grammar.

> prog =   do expr                -- prog: expr eof
>             Parser eof
              
> expr =   do sums                -- expr: sums (relop sums)?
>             (gt `mplus` ge `mplus` lt `mplus` le `mplus` eq `mplus` ne)
>          `mplus`
>          do sums

> gt =     do symbol ">"          -- relop: '>' sums
>             sums

> ge =     do symbol ">="         -- relop: '>=' sums
>             sums

> lt =     do symbol "<"          -- relop: '<' sums
>             sums

> le =     do symbol "<="         -- relop: '<=' sums
>             sums

> eq =     do symbol "="          -- relop: '=' sums
>             sums

> ne =     do symbol "!="         -- relop: '!=' sums
>             sums

> sums =   do prods               -- sums: prods (addop prods)*
>             many (add `mplus` sub)
>             return "sums"

> add =    do symbol "+"          -- addop: '+' prods
>             prods

> sub =    do symbol "-"          -- addop: '-' prods
>             prods

> prods =  do term                -- prods: term (mulop term)*
>             many (mul `mplus` div `mplus` mod)
>             return "prods"

> mul =    do symbol "*"          -- mulop: '*' term
>             term

> div =    do symbol "/"          -- mulop: '/' term
>             term

> mod =    do symbol "%"          -- mulop: '%' term
>             term

> term =   lEt
>          `mplus` letrec
>          `mplus` lambda
>          `mplus` cond
>          `mplus` parens
>          `mplus` call
>          `mplus` true
>          `mplus` false
>          `mplus` value
>          `mplus` id

> lEt =    do symbol "let"        -- let: 'let' (id '=' expr)+ 'in' expr
>             some (do id
>                      symbol "="
>                      expr)
>             symbol "in"
>             expr

> letrec = do symbol "letrec"     -- letrec: 'letrec' id '=' expr 'in' expr
>             id
>             symbol "="
>             expr
>             symbol "in"
>             expr

> lambda = do symbol "lambda"     -- lambda: 'lambda' id '.' expr
>             id
>             symbol "."
>             expr

> cond =   do symbol "cond"       -- cond: 'cond' (expr expr)+ 'end'
>             some (do expr
>                      expr)
>             symbol "end"
>             return "cond"

> parens = do symbol "("          -- parens: '(' expr ')'
>             expr
>             symbol ")"

> call =   do symbol "("          -- call: '(' expr expr+ ')'
>             expr
>             some expr
>             symbol ")"

> true =   do symbol "true"       -- true: 'true'

> false =  do symbol "false"      -- false: 'false'

> value =  do n <- number         -- value: number
>             return (show n)

> id =     do i <- identifier     -- name: identifier
>             if i `notElem` reserved then return i else fail "" where

>   reserved = [ "cond", "end",   -- but not reserved word
>                "false", "in", "lambda", "let", "letrec", "true" ]


Generated by GNU enscript 1.6.3.


